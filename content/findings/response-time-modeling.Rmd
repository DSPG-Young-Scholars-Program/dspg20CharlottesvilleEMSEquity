---
title: "Response Time Modeling"
output: html_document
---

```{r, echo = FALSE}
# setup
knitr::opts_chunk$set(echo = FALSE,  
                      message = FALSE, 
                      warning = FALSE,
                      fig.width = 8, 
                      fig.height = 6)
```

```{r}
load(here::here("data", "working", "model_objects", "basic_model_bayes_no_interact.RData"))
load(here::here("data", "working", "model_objects", "basic_model_bayes_yes_interact.RData"))
load(here::here("data", "working", "model_objects", "basic_model_freq_no_interact.RData"))
load(here::here("data", "working", "model_objects", "basic_model_freq_yes_interact.RData"))
load(here::here("data", "working", "model_objects", "neighbor_model_bayes_no_interact.RData"))
load(here::here("data", "working", "model_objects", "neighbor_model_bayes_yes_interact.RData"))

library(rstanarm)
library(bayesplot)
library(dplyr)
library(ggplot2)
library(sf)
library(broom)
library(purrr)
library(glue)
library(stringr)
library(viridis)
library(spdep)
library(ape)
library(leaflet)
library(leaflet.mapboxgl)

prepared_data <- readr::read_csv(here::here("data", "final", "response_time_model_data_prepared.csv"))
prepared_data_sp <- sf::st_read(here::here("data", "final", "response_time_model_data_prepared_sp.geojson"), quiet = TRUE)


freq_models <- list("basic_model_freq_no_interact" = basic_model_freq_no_interact,
                    "basic_model_freq_yes_interact" = basic_model_freq_yes_interact)

bayes_models <- stanreg_list("basic_model_bayes_no_interact" = basic_model_bayes_no_interact,
                             "basic_model_bayes_yes_interact" = basic_model_bayes_yes_interact,
                             "neighbor_model_bayes_no_interact" = neighbor_model_bayes_no_interact,
                             "neighbor_model_bayes_yes_interact" = neighbor_model_bayes_yes_interact)



bayes_model_coefs <- map(bayes_models, ~tidy(.x$stanfit,
                                             estimate.method = "median",
                                             conf.int = TRUE,
                                             conf.level = 0.95)) %>%
  map(~filter(.x, !(term %in% c("sigma", "mean_PPD", "log-posterior"))))


bayes_model_coefs_trans <- bayes_model_coefs %>%
  map(~mutate(.x, across(c(estimate,
                           conf.low,
                           conf.high),
                         list(scale_factor = ~exp(.x * (.x != .x[1])),
                              time_to_incident = ~exp(.x * (.x != .x[1]) + .x[1])))))


bayes_residuals <- map(bayes_models, residuals)

augmented_data <- prepared_data_sp %>% 
  mutate(resid_basic_no = bayes_residuals$basic_model_bayes_no_interact,
         resid_basic_yes = bayes_residuals$basic_model_bayes_yes_interact,
         resid_neighbor_no = bayes_residuals$neighbor_model_bayes_no_interact,
         resid_neighbor_yes = bayes_residuals$neighbor_model_bayes_yes_interact)

cbbPalette <- c("#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

term_dictionary <- tribble(~term, ~term_pretty,
                           "time_of_day", "Time of Day",
                           "response_vehicle_type_collapsedother", "Vehicle Type: Other",
                           "response_vehicle_type_collapsedmissing", "Vehicle Type: Missing",
                           "response_vehicle_type_collapsedfire apparatus", "Vehicle Type: Fire Apparatus",
                           "possible_impression_category_collapsedrespiratory", "Symptom Type: Respiratory",
                           "possible_impression_category_collapsedpain", "Symptom Type: Pain",
                           "possible_impression_category_collapsedother", "Symptom Type: Other",
                           "possible_impression_category_collapsedbehavioral", "Symptom Type: Behavioral",
                           "possible_impression_category_collapsedneuro", "Symptom Type: Neuro",
                           "possible_impression_category_collapsedmissing", "Symptom Type: Missing",
                           "possible_impression_category_collapsedinjury", "Symptom Type: Injury",
                           "possible_impression_category_collapsedinfectious", "Symptom Type: Infectious",
                           "possible_impression_category_collapsedgi/gu", "Symptom Type: GI/GU",
                           "possible_impression_category_collapsedendocrine", "Symptom Type: Endocrine",
                           "possible_impression_category_collapsedcv", "Symptom Type: Cardio Vascular",
                           "patient_gendermissing", "Patient Gender: Missing or Unknown",
                           "patient_gendermale", "Patient Gender: Male",
                           "patient_first_race_collapsedwhite", "Patient Race: White",
                           "patient_first_race_collapsedother", "Patient Race: Other",
                           "patient_first_race_collapsedmissing", "Patient Race: Missing",
                           "patient_age", "Patient Age",
                           "after_covidTRUE", "During Covid-19",
                           "(Intercept)", "Intercept")


sf_map_colors <- c('#7b3294','#c2a5cf','#d7d7d7','#a6dba0','#008837') 
```

## Response Time Modeling

One of the issues we wanted to examine within the emergency medical services data was whether some groups were being systematically served more quickly or more slowly by emergency medical services. In order to properly assess this issue, we adopted a modeling approach, which will be outlined below. At the highest level, we examined whether demographic features of the caller and the symptoms they present with are correlated with differnt response times. For example, would a 55 year old man with cardiovascular issues be served quicker than a 20 year old woman exhibiting symptoms of alcohol abuse? We were especially interested in how these differences may have changed with the advent of the Covid-19 Pandemic. 

### Model Specification

In order to arrive at our final model specification, we used an iterative process. We began by defining the covariates of interest, as well as covariates we wished to control for. We landed on the following variables:

* Covariates of Interest:
    + Age
    + Gender
    + Race
    + Symptoms present
    + Whether the Covid-19 pandemic had begun yet
* Covariates to Control For:
    + Type of vehicle responding
    + Travel time to location
    + Time of Day
    + Possible Spatial Effects

Due to issues with the data, we were unable to control for the travel time to a location, and instead used the neighborhood or census tract when outside of Charlottesville as a proxy for this. 

We began by using a simple linear model. Because the distribution of response time was heavily right skewed, we log transformed the data prior to fitting. Our model was as follows:

`log(Response Time) = Covid-19 Present * (Age + Gender + Symptoms Present + Type of Vehicle Responding + Time of Day)`

We included `Covid-19 Present` as an interaction term to better understand if the way these other factors impact response time has changed with the advent of Covid-19. 

This model performed resonably well, but didn't control for either spatial effects or travel time to location. Because of this we tried using instead a multilevel model. Expressed as an R formula, it was:

`log(Response Time) = Covid-19 Present * (Age + Gender + Symptoms Present + Type of Vehicle Responding + Time of Day) + (1|Neighborhood or Census Tract)`

By including the Neighborhood an incident occured in, we hoped to both deal with technical issues that arise when working with spatial data as well as the lack of a way to measure vehicle travel time. 

Both of these models were fit using Bayesian estimation with the R package `rstanarm`. Due to the superior performance of the model including neighborhoods, only the results from it are shown, although the results from the simple linear model are similar.

### Model Results

When fitting a Bayesian model, a common test to see if the model is well specified is to look at the predicted response times for each MCMC draw and see how they compare to the actual response times. This is called a posterior predictive check. Below we have the posterior predictive check for the model including neighborhood effects. 

```{r}
pp_check(neighbor_model_bayes_yes_interact)
```

The light blue lines are the models guesses for response times, and the dark blue is the real response times. The predictions follow the model closely, giving strong support to the strength of this model.
